package fileReader;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.Vector;

import processing.WordList;

import definitions.DictionaryEntry;
import definitions.ThesaurusEntry;
import dictionaries.DictionaryManager;
import dictionaries.WebParser;


public class XMLParser {

	private BufferedReader reader = null;
	
	/**
	 * The constructor takes the filepath of the file to be read.
	 * 
	 * @param filepath - absolute filepath
	 */
	public XMLParser(String filepath){
		if(filepath == null){
			System.err.println("XMLParser: No such file!");
			return;
		}
		filepath = filepath.trim();
		if(!filepath.endsWith(".xml")){
			System.err.println("XMLParser: Impoper file format!");
			return;
		}
		try {
			this.reader = new BufferedReader(new FileReader(filepath));
		} catch (FileNotFoundException e) {
			System.err.println("XMLParser: Invalid file!");
			this.reader = null;
		}
	}
	
	public WordList read(){
		String line = "";
		String name = "Default", version = "Unknown", source = "Merriam Webster";
		Vector results = new Vector();
		try {
			while((line = reader.readLine()) != null){
				if(line.contains("<title>")){
					line = line.replace("- Generated By Suhas Somnath", "");
					String[] splits = WebParser.getInsideTag(line, "<title>", "</title>");
					name = splits[0].trim();
					if(name.indexOf("_V.")>0){
						name = name.substring(0, name.indexOf("_V"));
						name = name.trim();
					}
				}else if(line.contains("<thesaurus>")){
					String[] splits = WebParser.getInsideTag(line, "<thesaurus>", "</thesaurus>");
					source = splits[0].trim();
				}else if(line.contains("<version>")){
					String[] splits = WebParser.getInsideTag(line, "<version>", "</version>");
					version = splits[0].trim();
				}else if(line.contains("<content>")){
					break;
				}
			}
			
			while((line = reader.readLine()) != null){
				if(line.toLowerCase().contains("</content>")){
					
					return new WordList(arrayFromVector(results),name,DictionaryManager.getDictionaryType(source),version);
				}
				if(line.toLowerCase().contains("<thesaurusentry>")){
					results.add(parseThesEntry());
				}
				if(line.toLowerCase().contains("<dictionaryentry>")){
					results.add(parseDictEntry());
				}
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}
	
	private Vector[] arrayFromVector(Vector v){
		Vector[] arr = new Vector[v.size()];
		for(int i=0; i< v.size(); i++){
			arr[i] = (Vector) v.get(i);
		}
		return arr;
	}
	
	private Vector<ThesaurusEntry> parseThesEntry(){
		String line = "";
		String word = null;
		Vector<ThesaurusEntry> vect = new Vector<ThesaurusEntry>();
		try {
			//reading word:
			word = reader.readLine();
			word = word.replace("<word>", "");
			word = word.replace("</word>", "");
			word = word.trim();
			
			//reading the number of entries line:
			line = reader.readLine();
			//must start with entry tag:
			while((line = reader.readLine()) != null){
				if(line.toLowerCase().contains("</thesaurusentry>")){
					return vect;
				}
				ThesaurusEntry current = parseSingleThesEntry();
				current.word = word;
				vect.add(current);
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;			
	}
	
	private ThesaurusEntry parseSingleThesEntry(){
		String line = "";
		ThesaurusEntry current = new ThesaurusEntry();
		try {
			while((line = reader.readLine()) != null){
				if(line.contains("</entry>")){
					return current;
				}
				int start = line.indexOf("<");
				if(start < 0) return null;
				
				int end = line.indexOf(">");
				if(end < 0) return null;
				
				if(start > end) return null;
				
				//validated starting tag presence
				
				String tag = line.substring(start+1,end);
				
				if(tag.toLowerCase().equals("meaning")){
					line = line.replace("</meaning>", "");
					line = line.replace("<meaning>", "");
					current.meaning = line.trim();
				}else if(tag.toLowerCase().equals("sentence")){
					line = line.replace("</sentence>", "");
					line = line.replace("<sentence>", "");
					current.sentence = line.trim();
				}else if(tag.toLowerCase().equals("synonym")){
					line = line.replace("</synonym>", "");
					line = line.replace("<synonym>", "");
					current.synonym = line.trim();
				}else if(tag.toLowerCase().equals("antonym")){
					line = line.replace("</antonym>", "");
					line = line.replace("<antonym>", "");
					current.antonym = line.trim();
				}else if(tag.toLowerCase().equals("nearant")){
					line = line.replace("</nearant>", "");
					line = line.replace("<nearant>", "");
					current.nearant = line.trim();
				}else if(tag.toLowerCase().equals("relword")){
					line = line.replace("</relword>", "");
					line = line.replace("<relword>", "");
					current.relword = line.trim();
				}else{
					return null;
				}
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}
	
	private Vector<DictionaryEntry> parseDictEntry(){
		String line = "";
		String word = null;
		Vector<DictionaryEntry> vect = new Vector<DictionaryEntry>();
		try {
			//reading word:
			word = reader.readLine();
			word = word.replace("<word>", "");
			word = word.replace("</word>", "");
			word = word.trim();
			
			//reading the number of entries line:
			line = reader.readLine();
			//must start with entry tag:
			while((line = reader.readLine()) != null){
				if(line.toLowerCase().contains("</dictionaryentry>")){
					return vect;
				}
				DictionaryEntry current = parseSingleDictEntry();
				current.word = word;
				vect.add(current);
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;	
	}
	
	private DictionaryEntry parseSingleDictEntry(){
		String line = "";
		DictionaryEntry current = new DictionaryEntry();
		current.meanings = new Vector<String>();
		try {
			while((line = reader.readLine()) != null){
				if(line.contains("</entry>")){
					return current;
				}
				int start = line.indexOf("<");
				if(start < 0) return null;
				
				int end = line.indexOf(">");
				if(end < 0) return null;
				
				if(start > end) return null;
				
				//validated starting tag presence
				
				String tag = line.substring(start+1,end);
				
				if(tag.toLowerCase().equals("meaning")){
					line = line.replace("</meaning>", "");
					line = line.replace("<meaning>", "");
					current.meanings.add(line.trim());
				}else if(tag.toLowerCase().equals("sentence")){
					line = line.replace("</sentence>", "");
					line = line.replace("<sentence>", "");
					if(current.sentence == null){
						current.sentence = new Vector<String>();
					}
					current.sentence.add(line.trim());
				}else if(tag.toLowerCase().equals("synonym")){
					line = line.replace("</synonym>", "");
					line = line.replace("<synonym>", "");
					current.synonym = line.trim();
				}else{
					return null;
				}
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}
	
	public static void main(String[] args){
		XMLParser xm = new XMLParser("test_db.xml");
		xm.read();
	}
}
